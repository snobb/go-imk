// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fsops

import (
	"context"
	"sync"
)

// Ensure, that WatcherMock does implement Watcher.
// If this is not the case, regenerate this file with moq.
var _ Watcher = &WatcherMock{}

// WatcherMock is a mock implementation of Watcher.
//
//	func TestSomethingThatUsesWatcher(t *testing.T) {
//
//		// make and configure a mocked Watcher
//		mockedWatcher := &WatcherMock{
//			WatchFunc: func(contextMoqParam context.Context) (chan *Event, error) {
//				panic("mock out the Watch method")
//			},
//		}
//
//		// use mockedWatcher in code that requires Watcher
//		// and then make assertions.
//
//	}
type WatcherMock struct {
	// WatchFunc mocks the Watch method.
	WatchFunc func(contextMoqParam context.Context) (chan *Event, error)

	// calls tracks calls to the methods.
	calls struct {
		// Watch holds details about calls to the Watch method.
		Watch []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
	}
	lockWatch sync.RWMutex
}

// Watch calls WatchFunc.
func (mock *WatcherMock) Watch(contextMoqParam context.Context) (chan *Event, error) {
	if mock.WatchFunc == nil {
		panic("WatcherMock.WatchFunc: method is nil but Watcher.Watch was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockWatch.Lock()
	mock.calls.Watch = append(mock.calls.Watch, callInfo)
	mock.lockWatch.Unlock()
	return mock.WatchFunc(contextMoqParam)
}

// WatchCalls gets all the calls that were made to Watch.
// Check the length with:
//
//	len(mockedWatcher.WatchCalls())
func (mock *WatcherMock) WatchCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockWatch.RLock()
	calls = mock.calls.Watch
	mock.lockWatch.RUnlock()
	return calls
}
